-- Digital Lock NuSMV module

-- TODO: Instantiations? 
-- inputs (from command line?)

MODULE main
VAR
        -- from positions 0-31 (32-39 ignored)
    position        : 0..31;
        -- 4 states in locking process, 0,12,21,15
    state           : 0..3;
        -- counter-clockwise movement of dial 
    upReg           : boolean;
        -- clockwise movement of dial 
    downReg         : boolean;

    --TODO: establish relationship between open and states (state[3] = open) 
    open            : boolean;

--IVAR 
    up              : boolean;
    down            : boolean;
    --clock           : boolean;



-- initializing each variable
ASSIGN
    position := 0;
    state    := 0;
    init (upReg)    := FALSE;
    init (downReg)  := FALSE;
    init (open)     := FALSE;

    next (open)     := 
    -- if we're in the last state, the lock is open
        case state = 3 : TRUE;
    -- otherwise it's closed
        TRUE : FALSE;
        esac;

    -- reachability states, not including inputs...
    -- This is probably not detailed enough, but was in the example. Better version below
    -- next (state)    := 
    --    case
    --       state = 0             :   {0, 1};
    --       state = 1             :   {0, 1, 2};
    --       state = 2             :   {0, 2, 3};
    --       state = 3             :   {0, 3, 4};
    --   esac;
    
    -- Defining when we're turning left or right
    next (upReg)        := up & !down;
    next (downReg)      := !up & down;
      
    -- states including input values and positions 
    next (state)    := 
        case
          --not needed...  up & down | !up & !down                         : break;        -- is this even legal?
            (state = 0) & (upReg) & (position = 12)          : 1;
            (state = 1) & (downReg) & (position  = 21)       : 2;
            (state = 2) & (upReg) & (position    = 15)       : 3;
            (state = 3) & (upReg | downReg)                  : 0; 
            -- No other combination of inputs will change the state 
        esac;

    next (position) :=
        case 
            (up & !down) & position = 0  : 31; 
            (!up & down) & position = 31  : 0;
            up & !down  : position - 1; 
            !up & down  : position + 1; 
            -- else it stays the same
        esac;

    -- specify that open happens when we're in state 3
    -- open            := state = 3;

            
-- have inputs/outputs? with IVAR up, down, clock


-- This property states that if the lock is open and it is not interrupted, it can remain open indefinitely.
SPEC AG (open & !up & !down) -> (open)

-- This property states that a transition to state two can only happen under the required circumstances.
SPEC AG (state=1 & !open & down & !up & position=21) -> (state=2)

-- This property states that if the lock is open and it is interrupted the the lock will close.
SPEC AG((open & up & !down) | (open & down & !up)) -> AX(!open)

-- This property states that it is always possible for the lock to be closed.
SPEC AG(EF(!open))

-- This property states that the lock will not open by counting down to 15.
SPEC AG(down & position=15) -> (!open)



